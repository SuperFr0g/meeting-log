# Spring
## 회원관리 - 웹 mvc
```
@Controller
public class MemberController {

    private final MemberService memberService;

    @Autowired
    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }

    @GetMapping("/members/new")
    public String createForm() {
        return "members/createMemberForm";
    }

    @PostMapping("/members/new")
    public String create(MemberForm form) {
        Member member = new Member();
        member.setName(form.getName());
        memberService.join(member);

        return "redirect:/";
    }

    @GetMapping("/members")
    public String list(Model model) {
        List<Member> members = memberService.findMembers();
        model.addAttribute("members", members);
        return "members/memberList";
    }
}
```
get방식이냐 post 방식이냐에 따라 `@GetMapping, @PostMapping`을 해준다. 기존에 만든 `MemberService`를 통해서 데이터를 등록하고, 등록한 데이터 리스트를 뿌려주는 예제이다.

## 스프링 DB 접근 기술
[H2데이터베이스](https://h2database.com/html/main.html) 교육용으로 쓰임

```
create table member
(
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);

select * from member;

insert into member(name) values('spring')
```
간단하게 member 테이블 생성

&nbsp;

build.gradle 파일에 jdbc. h2 데이터베이스 관련 라이브러리 추가

```
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'
```

```
// JdbcMemberRepository를 생성하여 DB와 연결되어 작동하는걸 만든다.
public class JdbcMemberRepository implements MemberRepositroy {

    private final DataSource dataSource;

    public JdbcMemberRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public Member save(Member member) {
        String sql = "insert int member(name) values(?)";

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

            pstmt.setString(1, member.getName());

            pstmt.executeUpdate();
            rs = pstmt.getGeneratedKeys();

            if(rs.next()) {
                member.setId(rs.getLong(1));
            } else {
                throw new SQLException("id 조회 실패");
            }
            return member;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public Optional<Member> findByID(Long id) {
        String sql = "select * from member where id = ?";

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setLong(1, id);

            rs = pstmt.executeQuery();

            if(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            } else {
                return Optional.empty();
            }
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public List<Member> findAll() {
        String sql = "select * from member";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            rs = pstmt.executeQuery();
            List<Member> members = new ArrayList<>();
            while(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                members.add(member);
            }
            return members;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public void clearStore() {

    }

    @Override
    public Optional<Member> findByName(String name) {
        String sql = "select * from member where name = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, name);
            rs = pstmt.executeQuery();
            if(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            }
            return Optional.empty();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    private Connection getConnection() {
        return DataSourceUtils.getConnection(dataSource);
    }

    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs) {
        try{
            if(rs != null) {
                rs.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if(pstmt != null) {
                pstmt.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if(conn != null) {
                close(conn);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void close(Connection conn) throws SQLException {
        DataSourceUtils.releaseConnection(conn, dataSource);
    }
}


// SpringConfig쪽만 간단하게 바꾸면 된다! 인터페이스의 편리함
@Bean
 public MemberRepository memberRepository() {
// return new MemoryMemberRepository();
return new JdbcMemberRepository(dataSource);
 }
```

이러한 것을 개방-폐쇄원칙(확장에는 열려있고, 수정 변경에는 닫혀있음) 이라 한다. 스프링 DI(Dependencies Injection)을  사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경 할 수 있다.

# React

## Immer 불변성 지키기
배열을 직접 수정해서 변경하는게 아닌, 배열을 복사해서 새로운 항목을 추가하거나 수정한다

Immer를 사용할 경우 불변성을 해치는 코드를 작성해도 알아서 불변성을 지켜준다.

`yarn add immer`

```
import produce from 'immer';

const state = {
    number: 1,
    dontChangeMe: 2
}

const nextState = produce(state, draft => {
    draft.number += 1;
}) // (해당객체, 변경메소드)
```
기존의 객체를 수정하는 불변성을 해치는 코드를 작성했지만 알아서 처리해준다.

기존 객체를 복사하지 않기 때문에, 코드가 더 깔끔해지고 이해해지기 쉽게 만들어진다.

```
const todo = {
    text: 'Hello',
    done: false
};

const updater = produce(draft => {
    draft.done = !draft.done;
});

const nextTodo = update(todo); // todo가 produce인자로 다이렉트로 들어감

console.log(nextTodo);
// {text: 'Hello', done: true}
```

## todo 만들기
```
yarn add styled-components react-icons
```

